/*********************************************
 *           Code generated by the           *
 * Altibase Precompiler2(APRE) Ver.1(7.1.0.1.2)*
 *********************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ulpLibInterface.h>

/* The variable _esqlopts specifies command-line options
 * {-n, -unsafe_null, stmt caching, ...}
 */
static short _esqlopts[10] = {0,0,1,0,0,0,0,0,0,0};

#include <sqlcli.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/time.h>

FILE *fp; 

struct timeval m_beginTime;
struct timeval m_endTime;
int m_elapsedTime = 0;


char  usr[10];
char  pwd[10];
int   port;
char  option[128];
long  key;


int ElapsedTime(struct timeval *beginTime, struct timeval *endTime)
{
    struct timeval v_timeval;
    int elapsedTime;

    v_timeval.tv_sec  = endTime->tv_sec  - beginTime->tv_sec;
    v_timeval.tv_usec = endTime->tv_usec - beginTime->tv_usec;

    if (v_timeval.tv_usec < 0)
    {
        v_timeval.tv_sec -= 1;
        v_timeval.tv_usec = 999999 - v_timeval.tv_usec * (-1);
    }
    elapsedTime = v_timeval.tv_sec * 1000000 + v_timeval.tv_usec;
    return( elapsedTime );
}

void ExecDML()
{
    char line[128];
    while( 1 )
    {
        if( fgets(line, sizeof(line), fp) != NULL )
        {
            key = atol(line);

            printf( "%ld\n", key );

            /*  DELETE FROM ORDERS WHERE O_ORDERKEY = :key; */
{
    struct ulpSqlstmt ulpSqlstmt;
    memset(&ulpSqlstmt, 0, sizeof(ulpSqlstmt));
    ulpHostVar ulpHostVar[1];
    ulpSqlstmt.hostvalue = ulpHostVar;
    ulpSqlstmt.stmttype = 3;
    ulpSqlstmt.stmtname = NULL;
    ulpSqlstmt.ismt = 0;
    ulpSqlstmt.numofhostvar = 1;
    ulpSqlstmt.statusptr = NULL;
    ulpSqlstmt.errcodeptr = NULL;
    ulpSqlstmt.isatomic = 0;
    ulpSqlstmt.stmt = (char *)"DELETE FROM ORDERS WHERE O_ORDERKEY = ? ";
    ulpSqlstmt.iters = 0;
    ulpSqlstmt.sqlinfo = 0;
    ulpSqlstmt.scrollcur = 0;
    ulpSqlstmt.cursorscrollable = 0;
    ulpSqlstmt.cursorsensitivity = 1;
    ulpSqlstmt.cursorwithhold = 0;
    ulpSqlstmt.esqlopts    = _esqlopts;
    ulpSqlstmt.sqlcaerr    = &sqlca;
    ulpSqlstmt.sqlcodeerr  = &SQLCODE;
    ulpSqlstmt.sqlstateerr = ulpGetSqlstate();
    ulpSqlstmt.hostvalue[0].mHostVar = (void*)&(key);
    ulpSqlstmt.hostvalue[0].mHostInd = NULL;
    ulpSqlstmt.hostvalue[0].isarr = 0;
    ulpSqlstmt.hostvalue[0].mType = 3;
    ulpSqlstmt.hostvalue[0].isstruct = 0;
    ulpSqlstmt.hostvalue[0].mSizeof = sizeof(long);
    ulpSqlstmt.hostvalue[0].mLen = 0;
    ulpSqlstmt.hostvalue[0].mMaxlen = 0;
    ulpSqlstmt.hostvalue[0].mUnsign = (short) 0;
    ulpSqlstmt.hostvalue[0].mInOut = (short) 0;
    ulpSqlstmt.hostvalue[0].mIsDynAlloc = (short) 0;
    ulpDoEmsql( NULL, &ulpSqlstmt, NULL );
}

            if(sqlca.sqlcode != 0)
            {
                printf("Error : [%d] %s\n\n", SQLCODE, sqlca.sqlerrm.sqlerrmc);
                exit(-1);
            }
            /*  DELETE FROM LINEITEM WHERE L_ORDERKEY = :key; */
{
    struct ulpSqlstmt ulpSqlstmt;
    memset(&ulpSqlstmt, 0, sizeof(ulpSqlstmt));
    ulpHostVar ulpHostVar[1];
    ulpSqlstmt.hostvalue = ulpHostVar;
    ulpSqlstmt.stmttype = 3;
    ulpSqlstmt.stmtname = NULL;
    ulpSqlstmt.ismt = 0;
    ulpSqlstmt.numofhostvar = 1;
    ulpSqlstmt.statusptr = NULL;
    ulpSqlstmt.errcodeptr = NULL;
    ulpSqlstmt.isatomic = 0;
    ulpSqlstmt.stmt = (char *)"DELETE FROM LINEITEM WHERE L_ORDERKEY = ? ";
    ulpSqlstmt.iters = 0;
    ulpSqlstmt.sqlinfo = 0;
    ulpSqlstmt.scrollcur = 0;
    ulpSqlstmt.cursorscrollable = 0;
    ulpSqlstmt.cursorsensitivity = 1;
    ulpSqlstmt.cursorwithhold = 0;
    ulpSqlstmt.esqlopts    = _esqlopts;
    ulpSqlstmt.sqlcaerr    = &sqlca;
    ulpSqlstmt.sqlcodeerr  = &SQLCODE;
    ulpSqlstmt.sqlstateerr = ulpGetSqlstate();
    ulpSqlstmt.hostvalue[0].mHostVar = (void*)&(key);
    ulpSqlstmt.hostvalue[0].mHostInd = NULL;
    ulpSqlstmt.hostvalue[0].isarr = 0;
    ulpSqlstmt.hostvalue[0].mType = 3;
    ulpSqlstmt.hostvalue[0].isstruct = 0;
    ulpSqlstmt.hostvalue[0].mSizeof = sizeof(long);
    ulpSqlstmt.hostvalue[0].mLen = 0;
    ulpSqlstmt.hostvalue[0].mMaxlen = 0;
    ulpSqlstmt.hostvalue[0].mUnsign = (short) 0;
    ulpSqlstmt.hostvalue[0].mInOut = (short) 0;
    ulpSqlstmt.hostvalue[0].mIsDynAlloc = (short) 0;
    ulpDoEmsql( NULL, &ulpSqlstmt, NULL );
}

            if(sqlca.sqlcode != 0)
            {
                printf("Error : [%d] %s\n\n", SQLCODE, sqlca.sqlerrm.sqlerrmc);
                exit(-1);
            }
        }
        else
        {
            break;
        }
    }
}	
   
void totalTime()
{
    double elapsedTime = 0.00;
    elapsedTime = (double)m_elapsedTime/1000000;
    printf("elapsed time : %.2f (sec)\n", elapsedTime);
}

void logon()
{
    strcpy(usr, "SYS");
    strcpy(pwd, "MANAGER");
    port = 20309;

    sprintf( option, "DSN=127.0.0.1;PORT_NO=%d", port );

    /*  CONNECT :usr IDENTIFIED BY :pwd USING :option; */
{
    struct ulpSqlstmt ulpSqlstmt;
    memset(&ulpSqlstmt, 0, sizeof(ulpSqlstmt));
    ulpHostVar ulpHostVar[3];
    ulpSqlstmt.hostvalue = ulpHostVar;
    ulpSqlstmt.stmttype = 1;
    ulpSqlstmt.stmtname = NULL;
    ulpSqlstmt.ismt = 0;
    ulpSqlstmt.sqlinfo = 0;
    ulpSqlstmt.numofhostvar = 3;
    ulpSqlstmt.esqlopts    = _esqlopts;
    ulpSqlstmt.sqlcaerr    = &sqlca;
    ulpSqlstmt.sqlcodeerr  = &SQLCODE;
    ulpSqlstmt.sqlstateerr = ulpGetSqlstate();
    ulpSqlstmt.hostvalue[0].mHostVar = (void*)usr;
    ulpSqlstmt.hostvalue[1].mHostVar = (void*)pwd;
    ulpSqlstmt.hostvalue[2].mHostVar = (void*)option;
    ulpDoEmsql( NULL, &ulpSqlstmt, NULL );
}

    if (sqlca.sqlcode != SQL_SUCCESS)
    {
        printf("Error : [%d] %s\n\n", SQLCODE, sqlca.sqlerrm.sqlerrmc);
        exit(-1);
    }
}

void logout()
{
    /*  DISCONNECT; */
{
    struct ulpSqlstmt ulpSqlstmt;
    memset(&ulpSqlstmt, 0, sizeof(ulpSqlstmt));
    ulpSqlstmt.stmttype = 2;
    ulpSqlstmt.stmtname = NULL;
    ulpSqlstmt.ismt = 0;
    ulpSqlstmt.numofhostvar = 0;
    ulpSqlstmt.esqlopts    = _esqlopts;
    ulpSqlstmt.sqlcaerr    = &sqlca;
    ulpSqlstmt.sqlcodeerr  = &SQLCODE;
    ulpSqlstmt.sqlstateerr = ulpGetSqlstate();
    ulpDoEmsql( NULL, &ulpSqlstmt, NULL );
}

    if(sqlca.sqlcode != SQL_SUCCESS)
    {
        printf("Error : [%d] %s\n\n", SQLCODE, sqlca.sqlerrm.sqlerrmc);
    }
}


int main(int argc, char **argv)
{
    if( argc != 2 )
    {
        printf( "usage: rf2 file\n" );
        exit(-1);
    }

    logon();

    fp = fopen( argv[1], "r" );

    if( fp == NULL )
    {
        printf( "fopen error: %s\n", argv[1] );
        exit(-1);
    }

    gettimeofday(&m_beginTime, NULL);
    ExecDML();
    gettimeofday(&m_endTime, NULL);
    m_elapsedTime = ElapsedTime(&m_beginTime, &m_endTime);
    totalTime();
    fclose(fp);

    logout();

    return 0;
}
