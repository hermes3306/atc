
/**

현재 Altibase 에 접속된 세션의 정보를 출력합니다. 

ID        :  Session ID 
CONN_INFO :  접속된 세션의 정보  
ACTIVE    :  Action 여부를 판단합니다. 
OPEN_STMT :  해당 세션이 연 모든 Statment 갯수 
CURRENT_STMT : 현재 수행 중인 Statement ID 
PROTOCOL :  접속 Protocol 
COMMIT_MODE  : Commit 모드 

**/

CREATE OR REPLACE VIEW ADM_SESSION AS
SELECT	ID, 
	REPLACE2(REPLACE2(COMM_NAME,'SOCKET-',NULL),'-SERVER',NULL) CONN_INFO,
	DECODE(ACTIVE_FLAG,1,'ACTIVE','INACTIVE') ACTIVE, 
	OPENED_STMT_COUNT OPEN_STMT,
	CURRENT_STMT_ID CURRENT_STMT,	
/*
	CLIENT_PID,DECODE(PROTOCOL_SESSION,
		1397051990,'HANDSHAKE FOR SYSDBA DISPATCH',
	        1094995278, 'HANDSHAKE FOR USERS DISPATCH',
	        1129270862, 'CONNECT',
	        1145652046, 'DISCONNECT',
		1229870668, 'INVALID',
		1280460613, 'TIMEOUT',
		1163022162, 'ERROR',
		1347568976, 'PREPARE',
		1163412803, 'EXECUTE',
		1162103122, 'EXECDIRECT',
		1179927368, 'FETCH',
		1179796805, 'FREE',
		1229931858, 'I/O ERROR',
		1161905998, 'EAGAIN ERROR',
		1480672077, 'XA COMMANDS',
		1094929998, 'ACKNOWLEDGE',
		1195725908, 'GET','UNKNOWN') PROTOCOL,
*/
	DECODE(AUTOCOMMIT_FLAG,0,'Non AutoCommit','AutoCommit') COMMIT_MODE
FROM V$SESSION;



/**

전체 테이블의 정보를 조회(Memory & Disk) 

TBS_NAME : Tablespace Name 
TABLE_NAME : Table Name 
ALLOCSIZE : Table 이 할당 받은 Size (Byte) 
TABLE_ID : Table Object ID 
REPL_COUNT : 해당 테이블에 걸린 리플리케이션 갯수 

**/


CREATE OR REPLACE VIEW ADM_TABLE AS
SELECT	/* for Memory Tables */ 
	'SYS_TBS_MEMORY' TBS_NAME,
	B.USER_NAME||'.'||A.TABLE_NAME TABLE_NAME,
	(C.FIXED_ALLOC_MEM+C.VAR_ALLOC_MEM) ALLOCSIZE,
	TABLE_ID, 
	REPLICATION_COUNT REPL_COUNT
FROM 	SYSTEM_.SYS_TABLES_ A, SYSTEM_.SYS_USERS_ B, V$MEMTBL_INFO C
WHERE 	A.USER_ID = B.USER_ID AND
	A.TABLE_OID = C.TABLE_OID AND
	A.TBS_ID=0 AND A.USER_ID != 1
	AND A.TABLE_TYPE='T'
UNION ALL
SELECT  /* for Disk Tables */ 
	C.NAME TBS_NAME,
	B.USER_NAME||'.'||A.TABLE_NAME TABLE_NAME,
	C.EXTENT_PAGE_COUNT*C.PAGE_SIZE*D.EXTENT_TOTAL_COUNT ALLOCSIZE,
	TABLE_ID, 
	REPLICATION_COUNT REPL_COUNT
FROM 	SYSTEM_.SYS_TABLES_ A, SYSTEM_.SYS_USERS_ B, V$TABLESPACES C, V$SEGMENT D
WHERE 	A.USER_ID = B.USER_ID AND 
	A.TBS_ID = C.ID AND 
	D.TABLE_OID = A.TABLE_OID AND
	D.SEGMENT_TYPE='TABLE' AND
	A.TBS_ID != 0 AND A.USER_ID != 1;


/**

Constraint 에 대한 조회 

TABLE_NAME : Contraint 가 설정된 테이블 명 
CONSTRAINT_NAME : Constraint 명 
CON_TYPE : Contraint 종류 
INDEX_NAME : 해당 Constraint 가 index 존재를 필요로 할 경우 해당 Index 명 
REFERENCE_TABLE : Constraint 가 FK 일 경우 참조하는 테이블 명 
REFERENCE_INDEX : Constraint 가 FK 일 경우 참조하는 인덱스 명 

**/

CREATE OR REPLACE VIEW ADM_CONSTRAINT AS
SELECT	C.USER_NAME||'.'||B.TABLE_NAME TABLE_NAME,
	A.CONSTRAINT_NAME,
	DECODE(A.CONSTRAINT_TYPE,0,'FOREIGNKEY',
		1,'NOTNULL',
		2,'UNIQUE',
		3,'PRIMARYKEY',
		4,'NULL',
		5,'TIMESTAMP','UNKNOWN') CON_TYPE,
	D.INDEX_NAME,
	(SELECT TABLE_NAME FROM SYSTEM_.SYS_TABLES_ IT WHERE IT.TABLE_ID = A.REFERENCED_TABLE_ID) REFERENCE_TABLE,
	(SELECT INDEX_NAME FROM SYSTEM_.SYS_INDICES_ II WHERE II.INDEX_ID = A.REFERENCED_INDEX_ID) REFERENCE_INDEX
FROM	SYSTEM_.SYS_CONSTRAINTS_ A LEFT OUTER JOIN SYSTEM_.SYS_INDICES_ D
ON A.INDEX_ID = D.INDEX_ID ,
	SYSTEM_.SYS_TABLES_ B, SYSTEM_.SYS_USERS_ C
WHERE	A.TABLE_ID = B.TABLE_ID AND 
	A.USER_ID = C.USER_ID
ORDER BY TABLE_NAME ,CON_TYPE;




/**

Segment 에 대한 조회 

SEG_NAME : Segment  명 
TBS_NAME : 테이블 스페이스 명 
SEGMENT_TYPE : Segment 형태 
EXTENT_TOTAL_COUNT : EXTENT 된 갯수 
ALLOC_SIZE : ALLOC 된 전체 사이즈 
EXTENT_FULL : EXTENT 될 수 있는 수량 

**/
CREATE OR REPLACE VIEW ADM_SEGMENT AS
SELECT 	C.USER_NAME||'.'||B.TABLE_NAME SEG_NAME,
	D.NAME TBS_NAME, 
	A.SEGMENT_TYPE, 
	EXTENT_TOTAL_COUNT EXTENT_COUNT,
	D.EXTENT_PAGE_COUNT*D.PAGE_SIZE*A.EXTENT_TOTAL_COUNT ALLOC_SIZE,
	EXTENT_TOTAL_COUNT EXTENT_FULL
FROM	 V$SEGMENT A, SYSTEM_.SYS_TABLES_ B, SYSTEM_.SYS_USERS_ C, V$TABLESPACES D
WHERE	
	A.TABLE_OID = B.TABLE_OID AND
	B.USER_ID = C.USER_ID AND
	A.SPACE_ID = D.ID AND 
	A.SEGMENT_TYPE='TABLE'
UNION ALL
SELECT 	C.USER_NAME||'.'||E.INDEX_NAME SEG_NAME,
	D.NAME TBS_NAME, 
	A.SEGMENT_TYPE, 
	EXTENT_TOTAL_COUNT EXTENT_COUNT,
	D.EXTENT_PAGE_COUNT*D.PAGE_SIZE*A.EXTENT_TOTAL_COUNT ALLOCSIZE,
	EXTENT_TOTAL_COUNT EXTENT_FULL
FROM	 V$SEGMENT A, X$INDEX B, SYSTEM_.SYS_USERS_ C, V$TABLESPACES D, SYSTEM_.SYS_INDICES_ E
WHERE
	A.SEGMENT_PID = B.INDEX_SEG_PID AND
	B.INDEX_ID = E.INDEX_ID AND
	E.USER_ID = C.USER_ID AND
	A.SPACE_ID = D.ID AND
	A.SEGMENT_TYPE='INDEX';

/**

모든 인덱스들의 대한 정보

INDEX_ID : Index ID 
TABLE_NAME : 해당 인덱스가 있는 테이블 명 
TBS : Index의 Tablespace 명 
UNIQUENESS : Unique Index 여부 
COLUMN_COUNT  : Column 갯수 


**/
CREATE OR REPLACE VIEW ADM_INDEX AS
SELECT	A.INDEX_ID, 
	C.USER_NAME||'.'||B.TABLE_NAME TABLE_NAME,
	A.INDEX_NAME INDEX_NAME,
	NVL(D.NAME,'MEMORY') TBS,
	DECODE(IS_UNIQUE,'T','UNIQUE','NONUIQUE') UNIQUENESS,
	A.COLUMN_CNT COLUMN_COUNT 
FROM	SYSTEM_.SYS_INDICES_ A LEFT OUTER JOIN V$TABLESPACES D
	ON A.TBS_ID = D.ID
	, SYSTEM_.SYS_TABLES_ B, SYSTEM_.SYS_USERS_ C
WHERE	A.TABLE_ID = B.TABLE_ID	AND 
	A.USER_ID = C.USER_ID
	AND C.USER_ID != 1
ORDER BY TABLE_NAME, INDEX_NAME ;



/**

인덱스에 속한 전체 컬럼명을 출력 

TABLE_NAME : 테이블명 
INDEX_NAME : 인덱스명 
COLUMN_NAME : 컬럼명 
COLUMN_ORDER : 해당 컬럼 Ordering 된 순서 
**/

CREATE OR REPLACE VIEW ADM_INDEX_COLUMN AS
SELECT	D.USER_NAME||'.'||C.TABLE_NAME TABLE_NAME,
	B.INDEX_NAME, 
	E.COLUMN_NAME,
	DECODE(SORT_ORDER,'A','ASC','D','DESC') COLUMN_ORDER
FROM	SYSTEM_.SYS_INDEX_COLUMNS_ A, SYSTEM_.SYS_INDICES_ B,
	SYSTEM_.SYS_TABLES_ C, SYSTEM_.SYS_USERS_ D,
	SYSTEM_.SYS_COLUMNS_ E
WHERE	A.INDEX_ID = B.INDEX_ID AND
	A.TABLE_ID = C.TABLE_ID AND
	A.USER_ID = D.USER_ID AND
	A.COLUMN_ID = E.COLUMN_ID AND
	D.USER_ID != 1
ORDER BY TABLE_NAME, INDEX_NAME, INDEX_COL_ORDER;



/**


CREATE OR REPLACE VIEW ADM_MEMTBL AS
SELECT
        A.TABLE_OID TABLE_OID,
        C.USER_NAME||'.'||B.TABLE_NAME TABLE_NAME,
        A.MEM_SLOT_SIZE SLOT_SIZE,
        FIXED_ALLOC_MEM+VAR_ALLOC_MEM ALLOC_BYTE,
        FIXED_USED_MEM+VAR_USED_MEM USED_BYTE,
        ROUND( (FIXED_USED_MEM+VAR_USED_MEM)/(FIXED_ALLOC_MEM+VAR_ALLOC_MEM)*100
,2) EFFICIENCY
FROM            V$MEMTBL_INFO A ,SYSTEM_.SYS_TABLES_ B, SYSTEM_.SYS_USERS_ C
WHERE           A.TABLE_OID = B.TABLE_OID AND B.USER_ID = C.USER_ID
AND C.USER_ID != 1
AND B.TABLE_TYPE = 'T'
ORDER BY TABLE_NAME;
**/


/**
전체 뷰에 대한 정보를 조회 
	
VIEW_NAME : 뷰 명 
VIEW_ID   : View Object ID 
STATUS	  : View 의 상태 

**/

CREATE OR REPLACE VIEW ADM_VIEW AS
SELECT	C.USER_NAME||'.'||B.TABLE_NAME VIEW_NAME,
	A.VIEW_ID,
	DECODE(A.STATUS,0,'VALID','INVALID') STATUS
FROM	SYSTEM_.SYS_VIEWS_ A, SYSTEM_.SYS_TABLES_ B,
	SYSTEM_.SYS_USERS_ C
WHERE A.VIEW_ID = B.TABLE_ID AND A.USER_ID=C.USER_ID
ORDER BY VIEW_NAME;




/**

시퀀스의 정보를 나타냄  

SEQ_NAME : SEQUENCE 명 
CURRENT_SEQ : 현재 SEQUENCE 번호 
START_SEQ   : SEQUENCE 시작 번호 
INCREMENT_SEQ : 증가 번호 
CACHE_SIZE : 캐시 
MAX_SEQ : 최대 값 
MIN_SEQ : 최소 값 
IS_CYCLE : 순환 여부 

**/

CREATE OR REPLACE VIEW ADM_SEQUENCE AS
SELECT	C.USER_NAME||'.'||B.TABLE_NAME SEQ_NAME,
	A.CURRENT_SEQ,
	A.START_SEQ, 
	A.INCREMENT_SEQ,
	A.CACHE_SIZE, 
	A.MAX_SEQ, 
	A.MIN_SEQ, 
	A.IS_CYCLE
FROM	V$SEQ A, SYSTEM_.SYS_TABLES_ B, SYSTEM_.SYS_USERS_ C
WHERE	A.SEQ_OID = B.TABLE_OID AND
	B.USER_ID = C.USER_ID AND
	B.USER_ID != 1
ORDER BY SEQ_NAME;



/**

사용자들의 시스템 권한을 조회 

USER_ID : User id 
USER_NAME : 사용자명 
DEFAULT_TBS_ID : 기본 테이블 스페이스 ID
DEFAULT_TBS_NAME : 기본 테이블 스페이스 명 
GRANTOR : 권한 부여자 
PRIV_NAME : 권한명 
**/

CREATE OR REPLACE VIEW ADM_USER_SYS_PRIV AS 
SELECT 
         Y.USER_ID, 
         Y.USER_NAME, 
         Y.DEFAULT_TBS_ID DEFAULT_TBS_ID, 
         DECODE(Y.DEFAULT_TBS_ID, 0, 'SYS_TBS_MEMORY', (SELECT NAME FROM V$TABLESPACES WHERE ID = 
Y.DEFAULT_TBS_ID)) DEFAULT_TBS, 
         (SELECT USER_NAME FROM SYSTEM_.SYS_USERS_ WHERE USER_ID = X.GRANTOR_ID) GRANTOR, 
         (SELECT PRIV_NAME FROM SYSTEM_.SYS_PRIVILEGES_ WHERE PRIV_ID = X.PRIV_ID) PRIV_NAME
FROM 
         SYSTEM_.SYS_GRANT_SYSTEM_  X INNER JOIN SYSTEM_.SYS_USERS_ Y ON X.GRANTEE_ID = Y.USER_ID 
WHERE 
	Y.USER_ID != 1
ORDER BY Y.USER_ID;


/**

메모리 테이블의 사용 정보를 조회 

TABLE_OID : 테이블 객체 아이디 
TABLE_NAME : 테이블명 
SLOT_SIZE : 슬롯 크기 
ALLOC_BYTE : 해당 테이블에 할당된 크기 
USED_BYTE  : 현재 사용중인 크기  
EFFICIENCY : 활용률 

**/

CREATE OR REPLACE VIEW ADM_MEMTBL AS 
SELECT 
	A.TABLE_OID TABLE_OID, 
	C.USER_NAME||'.'||B.TABLE_NAME TABLE_NAME, 
	A.MEM_SLOT_SIZE SLOT_SIZE,
	FIXED_ALLOC_MEM+VAR_ALLOC_MEM ALLOC_BYTE,
	FIXED_USED_MEM+VAR_USED_MEM USED_BYTE,
	ROUND( (FIXED_USED_MEM+VAR_USED_MEM)/(FIXED_ALLOC_MEM+VAR_ALLOC_MEM)*100,2) EFFICIENCY
FROM    	V$MEMTBL_INFO A ,SYSTEM_.SYS_TABLES_ B, SYSTEM_.SYS_USERS_ C
WHERE   	A.TABLE_OID = B.TABLE_OID AND B.USER_ID = C.USER_ID
AND C.USER_ID != 1
AND B.TABLE_TYPE = 'T'
ORDER BY TABLE_NAME;


/**

리플리케이션 정보 조회


REPLICATION_NAME : Replication Name
XSN              : Restart SN
REP_GAP          : Replication Gap
SENDER_STAT      : Sender 상태
RECEIVER_STAT    : Reciever 상태

**/

CREATE OR REPLACE VIEW ADM_REPLICATION AS
SELECT A.REPLICATION_NAME,
       A.XSN,
       NVL(TO_CHAR(E.REP_GAP), 'N/A') AS REP_GAP,
       D.HOST_IP || ' (' || D.PORT_NO || '):' || DECODE(B.STATUS, 0, 'STOP', 1, 'RUN', 2, 'RETRY', 'STOP') AS SENDER_STAT,
       DECODE(C.REP_NAME, NULL, 'OFF', 'ON') AS RECEIVER_STAT
  FROM
       SYSTEM_.SYS_REPL_HOSTS_ D,
       SYSTEM_.SYS_REPLICATIONS_ A
         LEFT OUTER JOIN V$REPSENDER B   ON A.REPLICATION_NAME = B.REP_NAME
         LEFT OUTER JOIN V$REPRECEIVER C ON A.REPLICATION_NAME = C.REP_NAME
         LEFT OUTER JOIN ( SELECT REP_NAME, MAX(REP_GAP) AS REP_GAP
                             FROM V$REPGAP
                            GROUP BY REP_NAME
                         ) E             ON A.REPLICATION_NAME = E.REP_NAME
 WHERE A.REPLICATION_NAME = D.REPLICATION_NAME
   AND A.LAST_USED_HOST_NO = D.HOST_NO
 ORDER BY A.REPLICATION_NAME
;
